Shader Implementation Details (1/18/18)
---------------------------------------
This will go over the individual shaders and the ideas behind their implementations.

Charge
======
The Charge shader is intended to mimmick the one present in TTYD. A 4x64 rainbow texture, ripped directly from TTYD, is used in this shader.

High-level Overview
-------------------
A rainbow texture is laid over the object, which has its alpha changed over time so the texture part fades in and out. The offset by which to sample the texture is also adjusted over time, so it appears that the rainbow texture is moving. These timers are global, so all objects rendered with the shader will have the same alpha value for the rainbow effect at all times.

Detailed
--------
We have several variables:

sampler s0; - The sampler for the rendered object. It's automatically loaded into the shader

Texture2D chargeTex; - A 4x64 rainbow texture, ripped directly from TTYD
sampler chargeSampler = sampler_state { Texture = <chargeTex>; }; - Sampler for sampling chargeTex

float chargeAlpha; - The alpha of the Charge texture
float4 objColor; - The TintColor of the object

float2 chargeOffset; - The offset to sample the Charge texture from
float chargeTexRatio; - The ratio between the Charge texture and the object's full texture (Ex. sprite sheet)
                        This is essentially: new Vector2(tex.Width, tex.Height) / new Vector2(spriteSheet.Width, spriteSheet.Height);
                        
Our steps are as follows:                        

1. Start by sampling the color of the pixel from the object's texture at the input coordinates (s0)
2. Fetch the corresponding coordinates scaled with the Charge texture. We only care about the Y, since the X values in the Charge texture are the same, so the coordinate ends up being input.TextureCoordinates.y / chargeTexRatio. This ensures that every time we reach the height of the Charge texture (Ex. 128 in obj texture when Charge tex has height of 64), we start back from the beginning of the Charge texture
3. Sample the color of the pixel at the coordinates on the Charge texture. this is simply the coordinates we found in step 2 + chargeOffset. We wrap those in a frac() call so that it wraps around the texture
4A. If the object texture's color doesn't have an alpha value, simply return the same color. We don't want to modify transparent pixels
4B. If it does have an alpha value, we now need to use both colors to get the final color. Multiply the Charge texture color we sampled with (chargeAlpha * objColor.a). This gets us a color scaled with both the Charge alpha and the object's own alpha.
  4B1. Finally, return the base color times the object's color added to the color we calculated. (color * objColor) takes into account the object's tint, and we simply add the Charge color onto that to get the final result